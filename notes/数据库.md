# Mysql

## mysql基本架构



![img](https://user-gold-cdn.xitu.io/2020/3/1/17096984bdc8443f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 连接器

负责与客户端建立链接、获取权限，维持和管理链接

建立链接时首先时TCP握手，然后是身份验证输入用户名密码，连上服务后处于空闲状态，可以通过SHOW PROCESSLIST查看连接列表，连接太久没响应裂解气就会自动断开连接，由wait_timeout参数控制，默认8小时

如果需要**长时间保持连接**，可以使用长连接，但是长连接比较消耗内存，容易造成OOM，可以通过定时断开连接，或者在占用内存较大操作后断开连接，需要时重连。也可以通过mysql_reset_connection重新初始化连接资源

mysql拿到查询请求会先到缓存中查询，只要之前执行过就会以kv形式存储在缓存中。但是缓存很容易失效，只要对表有更新，所有相关缓存都会失效。关闭缓存可以将query_cache_type设置成DEMAND，默认就不使用了。想用缓存就用SQL_CACHE。在SQL之前加SQL_NO_CACHE可以知道真正的查询时间。Mysql8.0之后就取消了。

### 分析器

未命中缓存继续执行的话就需要用到分析器了，首先是**词法分析**判断每个字符串代表的含义，然后是**语法分析**判断sql语句是否合法

### 优化器

优化器需要决定使用哪种索引（主键索引、联合索引等），决定执行顺序（先查那个表，还是先关联）

### 执行器

最后执行优化后的查询，执行的时候，就一行一行的去判断是否满足条件，有索引的执行起来可能就好点，一行行的判断就像是接口都提前在引擎定义好了，所以他比较快。

数据库的慢日志有个**rows_examined**字段，扫描多少行可以看到，还有**explain**也可以看到执行计划，我们扫描了多少行。

## 索引

索引有B+树和Hash两种数据结构

**为什么哈希表、完全平衡二叉树、B树、B+树都可以优化查询，为何Mysql独独喜欢B+树？**

**hash结构**的索引可能会出现hash冲突，而且hash支持精确查询不支持范围查询。所以这种结构更适合等值查询，也就是只有kv的情况，例如Redis这种NoSQL数据库。

**有序数组**支持等值查询和范围查询，但比较适合静态数据，在新增，修改，删除数据的时候会改变它的结构。适用于不会变动的历史数据，比如日志，购物记录，支付宝账单等。

**二叉树**查询性能和更新性能都是O(log(N))，需要保持二叉平衡树，但是不便于持久化

**B树** 比二叉树要矮，因为一个节点可以存多个元素，作为索引已经有较好的性能，但是比B+树范围查询的性能要差

![img](https://user-gold-cdn.xitu.io/2020/3/8/170baaef95fc7c13?imageslim)

**B+树** 就是B树的升级版，将非叶子节点冗余到叶子节点，在叶子节点间用指针连接，可以有效提高范围查询的效率。

B+树中一个节点存一页或一页的倍数最合适，因为多于一页或者小于一页都会造成资源的浪费

![img](https://user-gold-cdn.xitu.io/2020/3/8/170baaef96c4dc05?imageslim)

Mysql的基本存储结构是**页**，每个数据页之间可以组成双向列表，每个数据页的记录可以组成一个单向链表。每个数据页会为其中的记录生成页目录，在通过主键查找时通过二分法找到对应的槽，然后遍历快速找到指定记录。以其他列作为条件只能依次遍历每条记录

**回表** 就是先通过普通索引找到某条记录的id，再通过主键索引找到id的值，回到主键索引搜索的过程就叫回表。可以通过索引覆盖避免回表。

**索引覆盖** 就是在查询时select的字段全部被索引覆盖，那么在通过普通字段的索引查询时就可以获得需要的信息，就不需要回表了

**最左匹配原则** ：

* 索引可以简单如一列，也可以复杂如（a,b,c,d）即**联合索引**
* 如果是联合索引，那么key也有多个列组成，索引也只能用于判断是否存在，遇到范围查询则就不能进一步匹配了，后续退化为线性查找
* 列的排序决定了可命中索引的个数，Mysql会一直向右匹配直到遇到范围查询就停止匹配。

### 小结

* **最左匹配原则**：Mysql会一直向右匹配直到遇到范围查询就停止匹配。
* 尽量选择**区分度高的列作为索引**，区分度的公式是 COUNT(DISTINCT col)/COUNT(*)。表示字段不重复的比率，比率越大我们扫描的记录数就越少。
* **索引列不能参与计算，尽量保持列“干净”**。比如， FROM_UNIXTIME(create_time)='2016-06-06' 就不能使用索引，原因很简单，**B+树中存储的都是数据表中的字段值**，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ： create_time=UNIX_TIMESTAMP('2016-06-06')。
* 尽可能**扩展索引**而不是新建索引，单个多列组合索引和多个单列组合索引效果不同，虽然mysql5.0之后有**合并索引**的策略，但还是之间构建合理的索引比依赖合并索引来的可靠

## mysql调优

<img src="https://user-gold-cdn.xitu.io/2020/6/11/172a1288bf6acf91?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom: 80%;" />

### explain

explain通过模拟优化器显示了mysql使用索引，sql语句执行，表连接的状况。便于sql调优

<img src="http://www.pianshen.com/images/514/279a69dd40b087df8ce9c7a0adbd044a.png" alt="在这里插入图片描述" style="zoom:80%;" />

#### explain各字段解释

1. id：表示执行顺序，id不同则越大优先级不高，id相同则从上到下执行

   衍生虚表查询（Derived）：将查询结果构成新表作为查询条件。

2. select_type：查询的类型。共有六类：

   1. SIMPLE 简单查询，不包含子查询和联合查询
   2. PRIMARY 如果有子查询，最外层就被标记为PRIMARY 
   3. SUBQUERY select和where中的子查询被标记为SUBQUERY 
   4. DERIVED 在from中的子查询被标记为DERIVED，也就是衍生虚表查询
   5. UNION 多表联查中除了第一个以外的被标记为UNION，如果多表联查作为衍生虚表则第一张表标记为DERIVED
   6. UNION RESULT 从UNION中获取结果的SELECT

3. table  表示数据对应的表

4. partitions  （有疑问）

5. type  显示查询时使用的查询类型，常见的有其中性能由好到差依次是：

   system > const >eq_ref > ref > range >index >all

   1. system 整表只有一条记录
   2. const 常量查询，用于将主键或唯一索引和常量作比较，最多查出一条记录
   3. eq_ref  唯一性索引扫描，当两表用主键或者唯一索引做关联时出现
   4. ref   非唯一性索引扫描，对于每个索引可能有多行数据
   5. range 范围查询
   6. index  全索引扫描
   7. all  全盘扫描

6. possible_keys  查询字段上存在的索引

7. key   实际使用的索引，若为null表示没有使用索引，可能是没建索引也可能是用不到索引

8. key_len  表示索引使用的个数

9. ref   使用索引的是哪个字段

10. rows  索引查询时，大致估算出所需读取记录的行数，rows越小越好

11. filtered  （有疑问）

12. extra   记录额外信息，包括以下三种：

    1. Using filesort 表示准备的索引没有使用。可能是sql语句写法有问题，倒是索引冲突
    2. Using temporary 表示使用了临时表缓存中间结果，说明索引并未使用完全，常见于orderby，groupby和union
    3. Using index 表示用到了索引覆盖，如果同时又Using where 表示索引被用来做索引键值查找，没有表示只是用来读取数据

#### explain优化总结

1. 左前缀保留原则

   使用联合索引（a,b,c）时，查询从索引最左端开始，没有a，则bc使用不了该索引

2. 不对索引进行操作（计算，类型转换）

3. 最左匹配原则，数据库不能使用范围查询右边的索引

4. 使用不等号可能使索引失效

5. 使用like时，%要在字符串右边

6. 尽量实现索引覆盖

7. 字符串不加单引号，否则索引会失效

8. 少用or，否则索引会失效

9. 在创建table中数据时，字段的null/not null，要与explain select where列表中字段保持一致             **（有疑问）**

### 索引下推

Mysql5.6引入，在索引遍历时，会先判断索引中包含的字段，过滤掉不符合条件的记录，减少回表

### 唯一索引和普通索引如何选择

change buffer ，更新数据页时首先会判断数据页是否在内存中，如果在内存中则直接更新；如果不存在，在不影响数据一致性的情况下，会将更新操作缓存在change buffer中，在下一次查询该内存页时进行更新。change buffer不仅存在缓存中，也可以进行持久化，也就是存入磁盘中。将change buffer中的更新操作应用到数据中的过程称之为merge。数据库会定期merge，再关闭数据库时也会执行merge。change buffer可以减少IO访问，对性能提升效果显著。

change buffer对索引的影响就是只有普通索引可以使用change buffer。对于唯一索引，需要在更新时判断是否重复，所以必须要将数据页读入内存才可以进行判断，所以不支持。这就导致我们需要在不同的适用场景使用不同的索引类型。如果我们写多读少，写完立即被查询的可能性比较小，那么change buffer的效果比较好，例如账单，日志。但是如果写完立即会被查询，那么不仅不能提升性能，还会因为需要维持change buffer带来额外开销，就不需要使用change buffer

## Mysql事务

### 事务的基本要素（ACID）

* 原子性：要成功都成功，要失败都失败
* 一致性：事务开始前和完成后，数据的完整性约束不会被破坏
* 隔离性：同一时间，只允许一个事务请求同一数据
* 持久性：事务完成会持久化到数据库

### 事务并发问题

1. 脏读：事务A读取了事务B修改过的数据，然后事务B回滚了，A读取的数据就成了脏数据
2. 不可重复读：事务A多次读的过程中，事务B对该数据进行了修改并提交，导致多次读取数据不一致。
3. 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

### 事务隔离级别

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| :--------------------------- | :--: | :--------: | :--: |
| 读未提交（read-uncommitted） |  是  |     是     |  是  |
| 不可重复读（read-committed） |  否  |     是     |  是  |
| 可重复读（repeatable-read）  |  否  |     否     |  是  |
| 串行化（serializable）       |  否  |     否     |  否  |

**mysql默认的事务隔离级别为repeatable-read（可重复读）**

#### 1.读未提交

其他事务未提交的数据也可以被读取。

#### 2.不可重复读

写数据时会对该行上锁，解决脏读问题。

#### 3.可重复读

读数据时会对数据上写锁

实现方式：

mysql采用MVVC（多版本并发控制）实现可重复读，统一数据会与有多个版本，版本号就是导致这个版本的事务编号。可重复读会在事务开始时生成一个当前事务全局性的快照。而不可重复读则是在每次执行语句时生成快照。
快照可以督造的数据需要遵循以下规则：

1. 当前事务更新可以读到
2. 其他版本未提交不可读
3. 其他版本已提交，但在快照创建后提交的，不可读
4. 其他版本已提交，且在快照创建前提交的，可以读到

#### 4.串行化

事务按顺序完成

# Redis

keys方法会遍历redis数据库，单线程导致redis会阻塞一段时间，scan指令可以无阻塞的提取key列表，虽然会重复且耗时较长。

list实现消息队列，没有消息是可以使用blpop在没有消息时会阻塞，一次生产多次消费使用pub/sub发布订阅，最优解是使用消息队列中间件。延时队列使用zset，时间戳做score。

## Redis快的原因

* 基于内存实现，使用HashMap结构，查询和操作的时间复杂度都是O（1）
* Redis单线程，避免了上下文切换带来的内存开销
* 使用多路I/O复用模型，非阻塞IO
* 

## redis持久化

RDB全量持久化，AOF增量持久化。RDB通过创建子进程进行RDB操作（fork），实现copy on write（cow）。AOF用过配置可以设置每次操作记录或者定时记录

RDB性能影响小，数据恢复快，但是数据完整性差。AOF完整性好，且aof文件非常可读，，适合做灾难性数据误删除的恢复，QPS比RDB低，文件也较大

## pipeline作用

减少多次IO造成的的往返开销

## Redis同步机制

你启动一台slave 的时候，他会发送一个**psync**命令给master ，如果是这个slave第一次连接到master，他会触发一个全量复制。master就会启动一个线程，生成**RDB**快照，还会把新的写请求都缓存在内存中，**RDB**文件生成后，master会将这个**RDB**发送给slave的，slave拿到之后做的第一件事情就是写进本地的磁盘，然后加载进内存，然后master会把内存里面缓存的那些新命名都发给slave。然后将缓存的命令发给从节点。

master和slave连接断开时从节点可以主动重连，多个从节点同时重连时只会创建一个子进程写数据库镜像发送给各个从节点。redis2.8之前重连只会完全复制,之后则支持部分复制

## Redis集群

**Redis Cluster**

redis原生支持集群，实现主从复制和读写分离，redis cluster有N个主节点，每个主节点又有n个从节点

**Redis Sentinal（哨兵模式)**

三个定时任务:

1. 每十秒每个哨兵会对每个节点执行info,发现从节点，确认主从关系。
2. 每两秒哨兵间交互信息表达对节点的看法以及自身信息
3. 每一秒对其他哨兵和节点执行ping确认心跳

**主观下线**：当一个哨兵认为某个redis不可用即为主观下线

**客观下线：**多个哨兵都认为master处于主观下线状态，则该节点将被视为客观下线的状态，等待故障转移进行处理

**故障转移：**

1. 故障转移首先会在哨兵中票选出领导者哨兵，由领导者哨兵执行故障操作
2. 从从节点中选出最适合作为master的节点，如果存在slave-priority（从节点优先级）最高的节点则返回，如果存在复制偏移量最大的（数据复制最完整的）则返回，不然则返回runid最小的也就是最先运行的。判断完后执行slave of no one将其设置成主节点
3. 将从节点的主节点设置成新节点
4. 将原主节点设置为从节点，并保持关注，如果该节点恢复，则重新设置节点信息，更新数据

## Redis内存淘汰机制

Redis有惰性删除和定期删除两种策略

定时删除就是定时随机抽一些设置了过期时间的key，判断过期则删除。不全盘是因为数据量较大，效率太低

惰性删除就是在被查询时如果已经过期则删除

两种策略都没有处罚也没关系，因为redis有内存淘汰机制，官方给出的内存淘汰机制有以下几种：

* neoviction  内存占满时直接报错
* allkeys-random  内存占满时，回收随机的键
* volatile-random  内存占满时，回收随机的键，仅限过期的键
* allkeys-lru  占满内存时回收最近最少使用的键
* volatile-lru  占满内存时回收最近最少使用的键，仅限过期的键
* volatile-ttl   占满内存时回收存活时间较短的键，仅限过期的键

## Redis和memCache优缺点对比

## Redis Module

redis4.0之后支持了redis module，暴露了一部分指令，可以编写脚本，需要在配置文件中开启

## BloomFilter

布隆过滤器，通过多个hash算法和位运算判断是否存在，校验失败则必定不存在，校验成功可能会出现不存在的可能但基本都存在，成功率和hash算法数量以及位数正相关

## RedisSearch

RediSearch是一个高性能的全文搜索引擎，可作为一个Redis Module 运行在Redis上，是由RedisLabs团队开发的

## Redis-ML

## 缓存雪崩

在设置过期时间时，如果大量缓存在同时失效，大量请求直接访问数据库，会导致缓存雪崩，可以在设置时间时加上一个随机的偏移量。或者设置永不过期，在更新数据库时同时更新缓存。

## 缓存穿透

请求数据库中不存在的数据，无论多少次都会直接访问数据库，次数一多就会击垮数据库。参数校验和布隆过滤器可以很好的解决这个问题。nginx网关拉黑异常访问ip也是一种解决办法

## 缓存击穿

热点数据在过期的一瞬间导致大量请求击跨数据库，解决办法时设置数据永不过期.后台

后台更新，检查更新，分级缓存都可以解决这个问题

互斥锁ReentrantLock也可以解决该问题，获取缓存数据为空，获取锁，得到锁则查询数据库，没获得查询缓存，查询不到则sleep后重试