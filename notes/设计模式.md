# 工厂模式

工厂模式一般分为简单工厂模式、工厂方法模式、抽象工厂模式3种情况，属于创建型设计模式。

简单工厂就是一个接口多个实现类一个工厂，通过字符串生产实例

工厂方法模式就是定义一个抽象工厂，它定义了生产产品的方法，但不负责实现，具体实现由不同的派生类工厂完成。

抽象工厂就是定义一个超级工厂接口，定义多种产品的生产方法，在不同工厂实现中实现不同的生产。

# 单例模式

**使用场景：**

- 1、要求生产唯一序列号。
- 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
- 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。

几种实现方式：

1. 懒汉式，线程不安全，在需要时进行单例的初始化
2. 懒汉式，线程安全，使用synchronized上锁。
3. 饿汉式，未实现懒加载
4. 双检锁/双重校验锁DCL，先判断为空，上锁，在判断为空，再实例化对象
5. 静态内部类，在静态内部类中实例化对象，同样可以实现懒加载

# 原型模式

原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

原型类prototype需要实现Cloneable接口，重写clone方法，改写作用域

优点：比起new对象，Object的clone性能会好很多，尤其是对大对象。并且简化了创建对象的过程

缺点：和单例模式冲突，可以绕开构造方法实例化对象

深克隆浅克隆：

浅克隆只会拷贝基本数据类型，他们的封装类以及String，引用类型需要自己重新拷贝，





# 建造者模式

## 使用场景

**当一个类的构造函数参数较多，而且这些参数有些是可选的参数，考虑使用构造者模式。**

## 解决问题

- 方便用户创建复杂的对象（不需要知道实现过程）
- 代码复用性 & 封装性（将对象构建过程和细节进行封装 & 复用）

## 具体实现

指挥者（Director）直接和客户（Client）进行需求沟通；
沟通后指挥者将客户创建产品的需求划分为各个部件的建造请求（Builder）；
将各个部件的建造请求委派到具体的建造者（ConcreteBuilder）；
各个具体建造者负责进行产品部件的构建；
最终构建成具体产品（Product）。

# 适配器模式

适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。

在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。

根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。

## 类适配器

适配器类 继承 被适配者 实现 目标接口。在实现接口方法（@Override）中调用父类方法（super.request()），这样就能达到目标接口使用被适配着方法的效果。

## 对象适配器

适配器类 实现 目标接口，在适配器类中实例化被适配者并调用。区别在于不是会通过继承，而是通过关联实现适配器。

## 主要优点

将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。
增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。
灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。
具体来说，类适配器模式还有如下优点：

由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。
对象适配器模式还有如下优点：

一个对象适配器可以把多个不同的适配者适配到同一个目标；
可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。

## 类适配器模式的缺点

对于Java、C#等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者；
适配者类不能为最终类，如在Java中不能为final类，C#中不能为sealed类；
在Java、C#等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。

## 对象适配器模式的缺点

与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。

## 适用场景

系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。
想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。

# 装饰器模式

首先有一个产品抽象类，多个抽象类的具体实现，装饰器模式还需要一个装饰器抽象类集成产品抽象类，具体装饰类继承装饰器抽象类，具体装饰类构造时传入未装饰产品类。

# 代理模式

代理模式中的角色：

* 抽象主题角色（Subject）：声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。
* 具体主题角色（RealSubject)：也称为委托角色或者被代理角色。定义了代理对象所代表的目标对象。
* 代理主题角色（Proxy)：也叫委托类、代理类。代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。

代理模式又分为静态代理和动态代理。静态代理是由程序猿创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。动态代理是在程序运行时，通过运用反射机制动态的创建而成。

# 观察者模式

# 策略模式

# 模板模式



